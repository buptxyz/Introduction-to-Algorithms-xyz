最大堆：A[PARENT(i)] >= A[i]  在堆排序算法中用于升序排列
   
最小堆：A[PARENT(i)] <= A[i]  在堆排序算法中用于降序排列

堆排序的平均时间复杂度为 Ο(nlogn)

算法步骤
创建一个堆 H[0……n-1]；
把堆首（最大值）和堆尾互换；
把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；
重复步骤 2，直到堆的尺寸为 1



假设有一个待排序的列表 [4, 10, 3, 5, 1]，堆排序的过程如下：

构建最大堆：

初始列表：[4, 10, 3, 5, 1]。

从最后一个非叶子节点开始，逐步调整堆：

调整节点 5：[4, 10, 3, 5, 1]（无需调整）。

调整节点 10：[4, 10, 3, 5, 1]（无需调整）。

调整节点 4：[10, 5, 3, 4, 1]。

最终最大堆：[10, 5, 3, 4, 1]。

交换堆顶元素：

将堆顶元素 10 与最后一个元素 1 交换，列表变为 [1, 5, 3, 4, 10]。

堆的大小减 1，已排序部分为 [10]。

调整堆：

对新的堆顶元素 1 进行下沉操作：

比较 1 和其子节点 5、3，将 1 与 5 交换。

列表变为 [5, 1, 3, 4, 10]。

继续比较 1 和其子节点 4，将 1 与 4 交换。

列表变为 [5, 4, 3, 1, 10]。

调整后的堆：[5, 4, 3, 1]。

重复步骤：

将堆顶元素 5 与最后一个元素 1 交换，列表变为 [1, 4, 3, 5, 10]。

堆的大小减 1，已排序部分为 [5, 10]。

对新的堆顶元素 1 进行下沉操作：

比较 1 和其子节点 4、3，将 1 与 4 交换。

列表变为 [4, 1, 3, 5, 10]。

调整后的堆：[4, 1, 3]。

继续重复：

将堆顶元素 4 与最后一个元素 3 交换，列表变为 [3, 1, 4, 5, 10]。

堆的大小减 1，已排序部分为 [4, 5, 10]。

对新的堆顶元素 3 进行下沉操作：

比较 3 和其子节点 1，无需交换。

调整后的堆：[3, 1]。

最终步骤：

将堆顶元素 3 与最后一个元素 1 交换，列表变为 [1, 3, 4, 5, 10]。

堆的大小减 1，已排序部分为 [3, 4, 5, 10]。

堆的大小为 1，排序完成。